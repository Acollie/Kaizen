package visualization

import (
	"fmt"
	"math"
	"sort"
	"strings"

	"github.com/alexcollie/kaizen/pkg/models"
)

// SVGVisualizer generates SVG heat maps
type SVGVisualizer struct {
	width  int
	height int
}

// NewSVGVisualizer creates a new SVG visualizer
func NewSVGVisualizer(width, height int) *SVGVisualizer {
	if width == 0 {
		width = 1200
	}
	if height == 0 {
		height = 800
	}
	return &SVGVisualizer{
		width:  width,
		height: height,
	}
}

// Rectangle represents a treemap rectangle
type Rectangle struct {
	X      float64
	Y      float64
	Width  float64
	Height float64
	Label  string
	Value  int
	Score  float64
	Color  string
}

// GenerateSVG creates an SVG treemap visualization
func (visualizer *SVGVisualizer) GenerateSVG(result *models.AnalysisResult, metric string) (string, error) {
	// Build rectangles from folder metrics
	rectangles := visualizer.buildTreemap(result.FolderStats, metric)

	// Generate SVG
	var builder strings.Builder

	// SVG header
	builder.WriteString(fmt.Sprintf(`<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="%d" height="%d" viewBox="0 0 %d %d">
`, visualizer.width, visualizer.height, visualizer.width, visualizer.height))

	// Title and metadata
	builder.WriteString(`  <title>Kaizen Code Heat Map</title>
  <desc>Code quality heat map generated by Kaizen</desc>

`)

	// Define styles
	builder.WriteString(`  <defs>
    <style type="text/css">
      <![CDATA[
        .folder-rect {
          stroke: #1a1a1a;
          stroke-width: 2;
        }
        .folder-label {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          font-size: 12px;
          font-weight: 500;
          fill: white;
          text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
          pointer-events: none;
        }
        .title-text {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          font-size: 24px;
          font-weight: bold;
          fill: #667eea;
        }
        .subtitle-text {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          font-size: 14px;
          fill: #999;
        }
      ]]>
    </style>
  </defs>

`)

	// Background
	builder.WriteString(fmt.Sprintf(`  <rect width="%d" height="%d" fill="#1a1a1a"/>

`, visualizer.width, visualizer.height))

	// Header section
	headerHeight := 80
	builder.WriteString(fmt.Sprintf(`  <!-- Header -->
  <text x="%d" y="30" class="title-text" text-anchor="middle">Kaizen Code Heat Map</text>
  <text x="%d" y="55" class="subtitle-text" text-anchor="middle">Metric: %s | Files: %d | Functions: %d</text>

`, visualizer.width/2, visualizer.width/2, metricTitle(metric), result.Summary.TotalFiles, result.Summary.TotalFunctions))

	// Legend
	legendY := visualizer.height - 50
	builder.WriteString(visualizer.generateLegend(legendY))

	// Draw rectangles
	treemapHeight := visualizer.height - headerHeight - 80
	builder.WriteString(fmt.Sprintf(`  <!-- Treemap (offset by header) -->
  <g transform="translate(0, %d)">
`, headerHeight))

	for _, rect := range rectangles {
		builder.WriteString(visualizer.drawRectangle(rect, float64(treemapHeight)))
	}

	builder.WriteString(`  </g>

`)

	// Close SVG
	builder.WriteString(`</svg>`)

	return builder.String(), nil
}

// buildTreemap creates rectangles using a simple treemap algorithm
func (visualizer *SVGVisualizer) buildTreemap(folderStats map[string]models.FolderMetrics, metric string) []Rectangle {
	// Sort folders by size
	folders := make([]models.FolderMetrics, 0, len(folderStats))
	for _, folder := range folderStats {
		folders = append(folders, folder)
	}

	sort.Slice(folders, func(firstIndex, secondIndex int) bool {
		return folders[firstIndex].TotalCodeLines > folders[secondIndex].TotalCodeLines
	})

	// Calculate total value for normalization
	totalValue := 0
	for _, folder := range folders {
		totalValue += folder.TotalCodeLines
	}

	if totalValue == 0 {
		return []Rectangle{}
	}

	// Simple treemap layout using squarified algorithm (simplified)
	rectangles := []Rectangle{}
	headerHeight := 80
	legendHeight := 80
	availableHeight := float64(visualizer.height - headerHeight - legendHeight)
	availableWidth := float64(visualizer.width)

	currentX := 0.0
	currentY := 0.0
	rowHeight := 0.0
	rowWidth := 0.0

	for _, folder := range folders {
		score := getMetricScore(folder, metric)
		color := visualizer.getColorForScore(score)

		// Calculate rectangle size
		ratio := float64(folder.TotalCodeLines) / float64(totalValue)
		area := ratio * availableWidth * availableHeight
		rectWidth := math.Sqrt(area * (availableWidth / availableHeight))
		rectHeight := area / rectWidth

		// Simple layout: fill rows
		if currentX+rectWidth > availableWidth {
			// Move to next row
			currentY += rowHeight
			currentX = 0
			rowHeight = 0
		}

		rect := Rectangle{
			X:      currentX,
			Y:      currentY,
			Width:  rectWidth,
			Height: rectHeight,
			Label:  folder.Path,
			Value:  folder.TotalCodeLines,
			Score:  score,
			Color:  color,
		}

		rectangles = append(rectangles, rect)

		currentX += rectWidth
		if rectHeight > rowHeight {
			rowHeight = rectHeight
		}
		rowWidth += rectWidth
	}

	return rectangles
}

// drawRectangle draws a single treemap rectangle
func (visualizer *SVGVisualizer) drawRectangle(rect Rectangle, maxHeight float64) string {
	var builder strings.Builder

	// Scale to fit in available space
	scaleY := maxHeight / float64(visualizer.height)
	y := rect.Y * scaleY
	height := rect.Height * scaleY

	// Draw rectangle
	builder.WriteString(fmt.Sprintf(`    <rect class="folder-rect" x="%.2f" y="%.2f" width="%.2f" height="%.2f" fill="%s">
      <title>%s
Lines: %d
Score: %.1f/100</title>
    </rect>
`, rect.X, y, rect.Width, height, rect.Color, rect.Label, rect.Value, rect.Score))

	// Draw label if rectangle is large enough
	if rect.Width > 60 && height > 25 {
		labelX := rect.X + 5
		labelY := y + 20

		// Truncate label if too long
		label := rect.Label
		maxChars := int(rect.Width / 7) // Approximate characters that fit
		if len(label) > maxChars && maxChars > 3 {
			label = label[:maxChars-3] + "..."
		}

		builder.WriteString(fmt.Sprintf(`    <text class="folder-label" x="%.2f" y="%.2f">%s</text>
`, labelX, labelY, escapeXML(label)))
	}

	return builder.String()
}

// generateLegend generates the color scale legend
func (visualizer *SVGVisualizer) generateLegend(yPosition int) string {
	var builder strings.Builder

	legendWidth := 300
	legendHeight := 20
	legendX := (visualizer.width - legendWidth) / 2

	builder.WriteString(fmt.Sprintf(`  <!-- Legend -->
  <text x="%d" y="%d" class="subtitle-text" text-anchor="middle">Color Scale</text>
`, visualizer.width/2, yPosition-10))

	// Gradient legend
	numSteps := 50
	stepWidth := float64(legendWidth) / float64(numSteps)

	for step := 0; step < numSteps; step++ {
		score := (float64(step) / float64(numSteps)) * 100
		color := visualizer.getColorForScore(score)
		x := float64(legendX) + float64(step)*stepWidth

		builder.WriteString(fmt.Sprintf(`  <rect x="%.2f" y="%d" width="%.2f" height="%d" fill="%s" stroke="none"/>
`, x, yPosition, stepWidth+1, legendHeight, color))
	}

	// Legend labels
	builder.WriteString(fmt.Sprintf(`  <text x="%d" y="%d" class="subtitle-text" text-anchor="start">Low (Good)</text>
  <text x="%d" y="%d" class="subtitle-text" text-anchor="middle">Medium</text>
  <text x="%d" y="%d" class="subtitle-text" text-anchor="end">High (Needs Attention)</text>
`, legendX, yPosition+legendHeight+15,
		visualizer.width/2, yPosition+legendHeight+15,
		legendX+legendWidth, yPosition+legendHeight+15))

	return builder.String()
}

// getColorForScore returns an RGB color for a score (0-100)
func (visualizer *SVGVisualizer) getColorForScore(score float64) string {
	// Green → Yellow → Red gradient
	if score < 33 {
		// Green to Yellow
		t := score / 33.0
		return interpolateColor("#22c55e", "#eab308", t)
	} else if score < 67 {
		// Yellow to Red
		t := (score - 33) / 34.0
		return interpolateColor("#eab308", "#ef4444", t)
	} else {
		// Red to Dark Red
		t := (score - 67) / 33.0
		return interpolateColor("#ef4444", "#dc2626", t)
	}
}

// interpolateColor interpolates between two hex colors
func interpolateColor(color1, color2 string, ratio float64) string {
	// Parse hex colors
	r1, g1, b1 := hexToRGB(color1)
	r2, g2, b2 := hexToRGB(color2)

	// Interpolate
	redValue := int(float64(r1) + ratio*float64(r2-r1))
	greenValue := int(float64(g1) + ratio*float64(g2-g1))
	blueValue := int(float64(b1) + ratio*float64(b2-b1))

	return fmt.Sprintf("#%02x%02x%02x", redValue, greenValue, blueValue)
}

// hexToRGB converts hex color to RGB
func hexToRGB(hex string) (int, int, int) {
	hex = strings.TrimPrefix(hex, "#")
	var redValue, greenValue, blueValue int
	fmt.Sscanf(hex, "%02x%02x%02x", &redValue, &greenValue, &blueValue)
	return redValue, greenValue, blueValue
}

// escapeXML escapes XML special characters
func escapeXML(input string) string {
	input = strings.ReplaceAll(input, "&", "&amp;")
	input = strings.ReplaceAll(input, "<", "&lt;")
	input = strings.ReplaceAll(input, ">", "&gt;")
	input = strings.ReplaceAll(input, "\"", "&quot;")
	input = strings.ReplaceAll(input, "'", "&apos;")
	return input
}
